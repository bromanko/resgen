#!/usr/bin/env python
import fnmatch

import os
import logging
import optparse
import re
import datetime

logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s %(levelname)s %(message)s')

class Property:
    def __init__(self, name, fileName):
        self.name = name
        self.fileName = fileName

    def write_property_h(self, file):
        file.write('\n')
        file.write('- (NSString *)%s;\n' % self.name)
        file.write('\n')

    def write_property_m(self, file):
        file.write('\n')
        file.write('- (NSString *)%s {\n' % self.name)
        file.write('    return @"%s";\n' % os.path.basename(self.fileName))
        file.write('}\n')
        file.write('\n')

class Node:
    def __init__(self, name, path):
        self.name = name
        self.path = path
        self.parent = None
        self.nodes = []
        self.properties = []

    def full_name(self):
        full = self.name
        parent = self.parent
        while parent is not None:
            full = parent.name + "_" + full
            parent = parent.parent
        return full

    def write_singleton(self, file, type, name, isStatic):
        file.write('%s (%s *)%s {\n' % ("+" if isStatic else "-", type, name))
        file.write('    static dispatch_once_t once;\n')
        file.write('    static %s *sharedInstance;\n' % type)
        file.write('    dispatch_once(&once, ^{\n')
        file.write('        sharedInstance = [[%s alloc] init];\n' % type)
        file.write('    });\n')
        file.write('    return sharedInstance;\n')
        file.write('}\n')
        file.write('\n')

    def write_class(self, file):
        for n in self.nodes:
            n.write_class(file)

        file.write('@interface %s : NSObject\n' % self.full_name())

        if self.parent is None:
            file.write('+ (%s *)%s;\n' % (self.full_name(), "shared"))
            file.write('\n')

        for (p) in self.properties:
            p.write_property_h(file)

        for n in self.nodes:
            file.write('- (%s *)%s;\n' % (n.full_name(), n.name))
            file.write('\n')

        file.write('@end\n')
        file.write('\n')

        file.write('@implementation %s\n' % self.full_name())

        if self.parent is None:
            self.write_singleton(file, self.full_name(), self.full_name(), True)

        for (p) in self.properties:
            p.write_property_m(file)

        for n in self.nodes:
            self.write_singleton(file, n.full_name(), n.name, False)

        file.write('@end\n')
        file.write('\n')


def main():
    usage = "usage: %prog [options]"
    parser = optparse.OptionParser(usage)

    parser.add_option("-r", "--resource-folder", dest="resource_folder",
                      default="./resources",
                      help="Specifies the resources folder")

    parser.add_option("-c", "--class", dest="class_name",
                      default="R",
                      help="Specifies the name of the resources registry class")

    options, args = parser.parse_args()

    exists = os.path.isdir(options.resource_folder)
    if not exists:
        parser.error("The resource folder specified (%s) does not exist." % options.resource_folder)

    root = Node(options.class_name, options.resource_folder)
    walk_folder(root)

    rFilePath = os.path.join(options.resource_folder, options.class_name + '.h')
    logging.info('Creating "%s" resources registry class', rFilePath)
    rFile = open(rFilePath, 'w')

    write_header(options, rFile)
    root.write_class(rFile)
    rFile.close()

def walk_folder(node):
    includes = ['*.png', '*.jpg', '*.jpeg', '*.gif', '*.ttf', '*.otf', '*.mp3', '*.caf']
    includes = r'|'.join([fnmatch.translate(x) for x in includes])

    dirNames = []
    fileNames = []
    for dirPath in os.listdir(node.path):
        dirPath = os.path.join(node.path, dirPath)
        if os.path.isdir(dirPath):
            dirNames.append(dirPath)
        elif os.path.isfile(dirPath):
            fileNames.append(dirPath)

    filtered = [f for f in fileNames if re.match(includes, f)]
    for f in filtered:
        logging.debug("name: %s filename: %s" % (os.path.splitext(os.path.basename(f))[0], f))
        node.properties.append(Property(os.path.splitext(os.path.basename(f))[0], f))

    for dir in dirNames:
        logging.debug("Creating class %s" % dir)
        print
        child = Node(os.path.split(dir)[1], dir)
        node.nodes.append(child)
        child.parent = node
        walk_folder(child)

def write_header(options, file):
    file.write("//\n")
    file.write("//  %s.h\n" % options.class_name)
    file.write("//\n")
    file.write("//  Auto-generated by RBuilder on %s.\n" % datetime.datetime.now().strftime("%Y-%m-%d %H:%M"))
    file.write("//\n")
    file.write("\n")
    file.write("\n")

if __name__ == "__main__":
    main()